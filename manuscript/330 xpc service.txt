# Providing the Background Service

In your usual Cocoa MVC[^mvc] application, you start with a single application product target and its oft declined test target. You put everything you create in the product target, wire it together, run the app, and then you're done.

Our objective is different. We create two user interface applications which communicate with some kind of server. So we can't pass model objects around, and we can't take the usual shortcuts. Everything boils down to the connection of client and server, of an `NSXPCConnection` to an `NSXPCListener`.

The XPC service will contain all of the model stuff. It takes care of and enforces all the business rules. The user interface applications have to look out for constraints, too, but if they don't, nothing weird should happen thanks to the self-contained Domain Model. It won't let bad things happen. That's its job.

Writing XPC services is a bit different to single-process apps, so we proceed as follows:

1. Prepare the XPC service product target, which we've done already,
2. add an XPC service _core_ target to host the actual code and enable testing,
3. implement the Domain and expose ways to change it through well-separated layers in our architecture, writing unit tests on the way, and finally
4. test-drive the core through simple integration tests.

 [^mvc]: MVC stands for a design pattern called "Model, View, Controller"; Apple does promote this pattern through their application templates. You get a Core Data "model", some `NSViewController` subclass, and the actual view in Interface Builder NIB files. The patten was initially designed to give each view component its own controller and a model object, but that's not how people use it nowadays.

## Creating a Testable Target for the Domain

XPC service targets cannot be unit tested out of the box. Xcode won't let you add a testing target, and that's it.

A simple solution is to add yet another Cocoa Application target and put everything to be tested there. All of the code is going to have two targets afterwards: the new Cocoa Application target for testing purposes, and the XPC service target. The XPC Service target will be nothing more than a thin veneer around this fundamental core.

In fact, besides the `.entitlements` file, the XPC service target will contain nothing more than a `main.swift` file with the following content:

{title="The full main.swift file of the XPC service"}
    import Cocoa
    
    if let dependencies = Dependencies().setUp() {
        // Actually run the service (and never return)
        NSRunLoop.currentRunLoop().run()
    } else {
        NSLog("Couldn't start the XPC service")
        exit(EXIT_FAILURE)
    }

To get there, we


## Implement the Domain Model

The most interesting activity is located in Domain Services which express use case-specific processes. This doesn't have to be the case, but for the scope of this application, it is.

The innermost core of the Domain is composed of Aggregates, which are made of Entities. An Aggregate is a composition of Domain objects, and an Aggregate Root will be an Entity. The root Entity may have connections to other Entities, hiding them and their details from consumers of the Aggregate.

`Box` and `Item` are the only Entities we have to model. They connect to identifier Value Objects which we'll use in place of relying on value types like Int or String.

In an initial design, `Box` is the Aggregate Root with many items. You would access items only through a box object. This works fine for a lot of use cases. Later on, we revise this design and make `Item` the root of its own Aggregate, though: this enables us to access items independently of their box and actually move them around from one box to another without twisting our brain trying to make it work with two `Box` Aggregates instances.

The Domain Services will express the intent of user interaction:

- `ProvisioningService` creates `Box` and `Item` objects.
- `DistributeItem` takes care of finding a box for a new item.
- `RemoveItem` takes care of deleting an item.
- `DissolveBox` takes care of emptying and removing a box.

Additionally, the Domain will use Domain Events to publish change notifications and errors.

Then, there's the `DomainRegistry` singleton which is part factory, part global store of Domain Service objects.

That's about all there is going to be in the end.

After starting with the Aggregates, this chapter will put some Domain Services into spotlight. I aim to convey the modeling heuristics I applied. Once the basic patterns are clear, it becomes easier to model Domains in the future.


### Starting with the Aggregates

Boxes contain items. So it is natural to start with the `Box` Aggregate. Although `Item` is its own Entity, items will be accessed through the means of a box object only.

Compare the following two examples in respect to their expressiveness:

{linenos=off}
    // 1
    itemRepository.itemsWithBoxId(boxId)
    // 2
    box.items()

The first query isn't convoluted or anything, but you'd have to know what a Repository is, and that you can obtain items from there with a filter for those matching the criteria of belonging to a box with a given `boxId`.

The second query is much more expressive because the context is clear. We get all items of a box, duh!

Expressiveness is one of the main advantages of using a Domain Model instead of mere data containers and some means to read data from file or database.

We are going to aim for an expressive Model to make the code easy to read and easy to reason about.

#### Revisiting User Stories

In the [introducing section on user stories](#stories), the application specification was quite clear already. Here are the condensed versions, with all details about which tool does what stripped away:

- There's a _total capacity_ of all existing _boxes_.
- The user can _order_ new boxes with a _box capacity_ of 5, 10, or 20 items to increase total capacity.
- If `total capacity > 0`, the user can _add_ a new item. Items are _distributed_ among existing boxes evenly.
- The user can _remove_ items from boxes at will.
- The user can _remove_ boxes only if they're empty or the contents can be _re-distributed_ among leftover boxes.
- Boxes can be _assigned_ a custom _label_. (They have a default label otherwise.)
- Items have a required _title_.

These terms become part of our Ubiquitous Language and help create an expressive Domain Model.

#### Modeling the Box Aggregate According to User Stories

This is a stripped-down prototype of what Box may look like:

    class Box {
        let boxId: BoxId
        
        // Box label
        private(set) var label: String
        func assignLabel(label: String) { ... }
        
        // Box capacity
        let capacity: BoxCapacity
        var remainingCapacity: Int { ... }  // computed property: capacity - itemsCount
        
        func canTakeItem() -> Bool { ... } // if remainingCapacity > 0

        init(boxId: BoxId, capacity: BoxCapacity, label: String) { ... }
        
        // Contained items
        private var items: [Item] = []
        var itemsCount: Int { ... }  // computed property
        
        func addItem(item: Item) { ... }
        func item(#itemId: ItemId) -> Item? { ... }
        func removeItem(#itemId: ItemId) { ... }
    }

It takes care of and protects its invariants. You shouldn't be able to change its properties willy-nilly.

For example, `box.items.append(item)` would not match the user story in expressiveness: Nowhere did we say "appending" in our user stories. It's too explicit on the side of implementation, while obscuring the intent. The user story doesn't care if we use an array (to which we have to _append_) or an unordered set (to which we can simply _add_) internally. Conversely, client objects shouldn't have to worry about these implementation details. 

For client code, `Box` exposes collection-like methods. It behaves like an unordered collection itself, and for the sake of its clients, it is nothing more but a labeled collection with a cap on the element count.

The `items` array is private for this exact reason: to protect a box from external changes. All changes to the Aggregate composite have to flow through the root's public interface.

The `Item` class is pretty dumb in comparison:

    public class Item: NSObject {
        let itemId: ItemId
        let title: String
    
        init(itemId: ItemId, title: String) { ... }
    }

Both `Box` and `Item` are implemented in a straightforward manner. There's no magic taking place anywhere, so I leave the code out. Since an item can only be fetched through a box, I didn't include a backward relationship to `Box` in `Item`. It wouldn't ever be used anyway.[^201503241555]

[^201503241555]: You can find the code [as of March 4th, 2015](https://github.com/DivineDominion/mac-multiproc-code/tree/4a0439bbf9e3e628543962ac87c889308b109ea1/RelocationManagerServiceDomain), on Github. In yet upcoming commits, the interface will change. We will focus on the changes in subsequent sections of this chapter.

#### Identifier Value Objects

The interesting thing about Entities is their identity. Entities change. Values, on the other hand, are replaced.

Common examples of custom Value Objects are: money and currency, weight, length and units of length. Real-world stuff mostly. You could represent an amount of money as a double, but you better create a dedicated structure to help you with currency conversion. From Cocoa, you may now `NSDateComponents`, although this class breaks the convention of value immutability. Wherever you design Value Objects to be immutable, you close a door for bugs. 

With Swift, we have to write a lot less Value Objects ourselves in simple applications.

Before Swift, you had to create your own `Boxes` class (note the plural!) as a wrapper around `NSArray` to take only items which inherit from `Box` or `Box` objects themselves. There was no other way to ensure a collection wasn't dirtied. Thanks to generics, we can specify the kind of object an array should accept.

This mostly leaves identifiers for our case.

I prefer 64bit integer UUIDs to string-based UUIDs because they take up less space. Because we use both `BoxId` and `IntegerId` to identify Entities, a common protocol can aid us in pointing out similarities and writing identifier generators later on:

    public typealias IntegerId = Int64

    public protocol Identifiable {
        var identifier: IntegerId { get }
        init(_ identifier: IntegerId)
    }

Now have a look at one concrete identifier, `ItemId`:

    public struct ItemId: Identifiable, Equatable, Hashable {
        public let identifier: IntegerId
    
        // convenience for serialization to dictionary
        public var number: NSNumber { return NSNumber(longLong: identifier) }
    
        public init(_ identifier: IntegerId) {
            self.identifier = identifier
        }
    
        init(_ identifierNumber: NSNumber) {
            self.identifier = identifierNumber.longLongValue
        }
    
        public var hashValue: Int {
            return self.identifier.hashValue
        }
    }
    
    public func ==(lhs: ItemId, rhs: ItemId) -> Bool {
        return lhs.identifier == rhs.identifier
    }

`BoxId` is mostly the same, but in this case code duplication doesn't mean we miss an abstraction. `BoxId` and `ItemId` shouldn't change together as long as the `Identifiable` protocol didn't change, so there's just no wiggle-room left for another level of abstraction.

So that's what identifiers do: they just are, and they can be compared to other instances for equality. This way, they represent a means to identify an Entity.

From a programmer perspective, they're a wrapper around 64bit integer UUIDs. But that's not what they are in respect to the Domain.

That's it for the inner core already. We've got two Entity types, one being root of the sole Aggregate in the Domain. And we've got identifier Value Objects. What's left is a representation of the means to actually modify the system.

What's left is Domain Services to implement the user stories.

### `DistributeItem` -- Domain Service to Create New Items

The command we will look at is `DistributeItem`. It takes an item's title, creates the item, and puts the new item into a box that can actually hold the item.

On the way, we will take a look at creating Entities. And we'll refactor our core Domain to accommodate to a simple fact I have overlooked so far: moving items is possible only if an item becomes independent from its box in some cases. It has to be part of another Aggregate, without destroying the old one, though.

But first, let us find out how Domain Services come into play.

`DistributeItem`'s job is to create a new item and put it somewhere. Simple as that.

There are obvious guard clauses: if there are no boxes, fail. If all boxes are full, fail. Instead of making these checks individual guard clauses up front, though, we can put the set of all boxes through a few filter mechanisms and see what's left:

    public class DistributeItem {
        let repository: BoxRepository
    
        public init(repository: BoxRepository) {
            self.repository = repository
        }
    
        public func distribute(itemTitle title: String) {
            if let box = boxes().first {
                // success!
                return
            }
        
            // failure
        }
        
        /// Retrieve all non-full boxes, sorted by remaining capacity
        func boxes() -> [Box] {
            return repository.boxes().filter { box in
                return box.canTakeItem()
            }.sorted { (one, other) -> Bool in
                return one.remainingCapacity < other.remainingCapacity
            }
        }
    }

This does the following:

1. Fetch all boxes, out of any order, via `repository.boxes()`.
2. Remove all filled boxes from the result via `filter()`.
3. Sort remaining boxes by the amount of items they contain via `sorted()`.
4. Pick the first one from the stack, that is the box with the least items in it, if possible.

Although using `filter()` and `sorted()` may look uncanny to the untrained eye, you can read the code from top to bottom and see what is done. If nothing satisfies the filter criteria, the resulting array will be empty. Simple as that.

This functional approach sometimes is superior to explicit guard clauses which abort method execution. It this case, we don't have to first see whether there are any boxes in the Repository at all (or abort), then iterate over all boxes and see whether one or more have room for another item (or abort), and then trim and sort the set. Instead, we filter the set according to our needs and bring it into order.

I didn't add a convenience method like `boxesSortedByItemCount()` to the `BoxRepository` because its used in only this one particular place. If it were used more often, I'd definitely move this utility method into the Repository class. For now, let's stick to the minimum amount of deviation from a pure specification-driven Domain.

A convenience method on `BoxRepository` wouldn't even allow fetch optimizations in our case. Core Data cannot sort by the amount of connections from box to items while fetching. It cannot even filter out full boxes. The predicate to achieve the latter is `items.@count`, a so-called aggregate function. You can express this in `NSPredicate`, but you have to fetch the objects and their resulting relationships before applying the filter predicate. So after fetching, either `NSPredicate` filtering and our functional array  filters will work. I rather stick to the latter because I find it more expressive.


#### Handling Success and Failure Scenarios

The operation can fail. So there's two possible outcomes. We need to deal with both and figure out how to communicate what has happened to the client app.

Return values and callbacks come to mind.

We could return a boolean. `distribute(_:)` is a command, though, so it shouldn't return a value. But returning `true` or `false` might do the job without dealing much damage.

We could add a `successCallback: () -> ()` and a `noCapacityCallback: () -> ()` parameter, for example. But I think the callback blocks are disproportionate to the effect we want to achieve. After all, `DistributeItem` isn't even in the outermost layer. The callbacks will be provided by Services in the Application Layer -- and then the Application Service will have to figure out how to report success/failure to _its_ caller, and so on.

Returning a boolean has a similar disadvantage: you have to pass the result all the way up the call chain to the client somehow.

That's the benefit of higher coupling: you know what you have, and you know what you will get. But then you just have this one way to deal with failure: by passing the result around like a hot potato.

Instead, understand _why_ we want to couple and return the result of a potentially failing operation, first. Maybe we can find another way afterwards.

The usual tactics for communicating results centers around _immediacy_: you call a method, you expect a reaction. This is a synchronous operation. The concept is easy to learn and easy on the mind while reading code.

If you separate commands from queries, you won't allow commands to communicate the result via return values. Commands are there to produce change only. Now you end up with easy-to-understand operations on one side, and a promise to keep your code and your application in shape for a long time on the other.

We're trained and spoilt to expect something similar to a query's response, with results returning synchronously. That's a reason we want to design objects to react immediately. We end up creating client code like this all over the place: Call a method, expect change, check the outcome, react accordingly. And because we design our objects to return something after commands, we keep the habit.

The need to react to change in appropriate moments can be fulfilled by objects which are not the calling object itself. How's that?

Enter the wonderful world of Domain Events and notifications.

#### Introducing (Domain) Events

We can decouple command execution from response handling through events.

When we send events, we don't have to know the interested parties. That's an advantage over method invocations. Even if in fact only one subscriber exists per message, the benefit of hiding its existence from the sender can be worth the overhead: we won't design the sender to accommodate to the receiver and increase coupling implicitly.

Cocoa spoils us: `NSNotificationCenter` works just great. The only thing you have to take care of is sending a notification of the right `name` with sufficient `userInfo`. This is error-prone, because only in runtime will we find whether we forgot to add an expected key-value-pair to the `userInfo` dictionary. So we will fix that and then we're ready to roll.

We can let the compiler help us in sending events with all necessary data by wrapping notifications in custom data structures, or Value Objects.


##### The ItemDistributionFailed Event

Here's my take on the failure event, `ItemDistributionFailed`, as a template for Domain Events:

    public struct ItemDistributionFailed: DomainEvent {
        public static var eventType: DomainEventType {
            return DomainEventType.ItemDistributionFailed
        }
    
        public let itemTitle: String
    
        public init(itemTitle: String) {
            self.itemTitle = itemTitle
        }
    
        public init(userInfo: UserInfo) {
            let itemData = userInfo["item"] as UserInfo
            let itemTitle = itemData["title"] as String
        
            self.init(itemTitle: itemTitle)
        }
    
        public func userInfo() -> UserInfo {
            return [
                "item" : [
                    "title": itemTitle
                ]
            ]
        }
    
        public func notification() -> NSNotification {
            return NSNotification(name: self.dynamicType.eventType.name, object: nil, userInfo: userInfo())
        }
    }

Instances can be created in two ways: 

1. `ItemDistributionFailed(itemTitle: "...")`, which we'll use when we send an event, and
2. `ItemDistributionFailed(userInfo: ["item" : ["title" : "..."]])`, which we'll never invoke manually but which is useful for re-creating an event object instance from `NSNotification` `userInfo`.

The event can create an `NSNotification` object on its own with the data available. I decided to put the types of events available into a string-based `enum` called `DomainEventType`. But it would work just as well if the event name was a static string or if you decide to make a string of the struct's name through `_stdlib_getDemangledTypeName()` or similar.

With this event boilerplate in place, `DistributeItem.distribute` can now communicate failure through a `DomainEventPublisher`:

        var eventPublisher: DomainEventPublisher {
            return DomainEventPublisher.sharedInstance
        }
        
        public func distribute(itemTitle title: String) {
            if let box = boxes().first {
                // success!
                return
            }
            
            // Publish failure event
            eventPublisher.publish(ItemDistributionFailed(itemTitle: title))
        }

To create other events in the future, here's the `DomainEvent` protocol which specifies the shared bare minimum:

    public typealias UserInfo = [NSObject : AnyObject]
    
    public protocol DomainEvent {
        /// The `DomainEventType` to identify this kind of DomainEvent
        class var eventType: DomainEventType { get }
    
        init(userInfo: UserInfo)
        func userInfo() -> UserInfo
        func notification() -> NSNotification
    }

##### The DomainEventPublisher and its DomainEventSubscription Counterpart

`DomainEventPublisher` is a wrapper around sending `NSNotification` objects through a common `NSNotificationCenter`. The nice thing about this is that you can replace either the `DomainEventPublisher` during unit tests or create per-test `NSNotificationCenter` objects to verify actual event delivery.

At its core, it looks like this:

    public class DomainEventPublisher {
        // ...
        
        public func publish(event: DomainEvent) {
            notificationCenter.postNotification(event.notification())
        }
        
        public func subscribe<T: DomainEvent>(eventKind: T.Type, usingBlock block: (T!) -> Void) -> DomainEventSubscription {
            // Pick a different default queue if you want async event processing
            let mainQueue = NSOperationQueue.mainQueue()
    
            return self.subscribe(eventKind, queue: mainQueue, usingBlock: block)
        }

        public func subscribe<T: DomainEvent>(eventKind: T.Type, queue: NSOperationQueue, usingBlock block: (T!) -> Void) -> DomainEventSubscription {
            let eventType: DomainEventType = T.eventType
            let observer = notificationCenter.addObserverForName(eventType.name, object: nil, queue: queue) {
                notification in
        
                let userInfo = notification.userInfo!
                let event: T = T(userInfo: userInfo)
                block(event)
            }
            
            return DomainEventSubscription(observer: observer, eventPublisher: self)
        }
        
        public func unsubscribe(subscriber: AnyObject) {
            notificationCenter.removeObserver(subscriber)
        }
    }

The full source is [available online][publisher].

Let's talk about subscription a bit.

I never used `addObserverForName(_:,object:,queue:)` much in the past. In case you didn't either: it basically creates an observer object of type `NSObjectProtocol` which is tied to the notification parameters so you don't have to call the verbose `removeObserver(_:,name:,object:)` later on to get rid of it. It suffices to simply use `removeObserver(_:)`.

The observer object takes a block. If the notification is triggered, the block is invoked and an `NSNotification` is passed in. From this, we can re-create an appropriate Domain Event object.

The resulting `DomainEventSubscription` merely takes care of unsubscribing automatically when its reference is nilled out:

    public class DomainEventSubscription {
        let observer: NSObjectProtocol
        let eventPublisher: DomainEventPublisher
    
        public init(observer: NSObjectProtocol, eventPublisher: DomainEventPublisher) {
            self.observer = observer
            self.eventPublisher = eventPublisher
        }
    
        deinit {
            eventPublisher.unsubscribe(observer)
        }
    }

##### Using the Event Delivery System

Now that's all of the prerequisites. From now on, we can focus on actually using the Domain Event publishing system.

Interested parties subscribe like this:

    let eventPublisher = DomainEventPublisher.sharedInstance
    let subscription = eventPublisher.subscribe(ItemDistributionFailed.self) {
        event in
        
        // React to event, like so:
        NSLog("Distribution of item '\(event.itemTitle)' failed.")
    }

The incoming event is of kind `ItemDistributionFailed`, which is inferred from the first parameter of `subscribe(_:,block:)`. That's what generics do: we allow a method to take a parameter of virtually any type as long as it adheres to the `DomainEvent` protocol. Then we use the type placeholder in a block to specify it'll receive an object of the same type, whichever that is.

This is the first use of a Domain Event, so I got into a lot of detail. We will utilize Domain Events a lot more often from now on to tackle similar problems. To use new event types so, we need to perform three steps:

1. Add a new Domain Event type which implements the `DomainEvent` protocol,
2. add a `DomainEventType` entry for the name and use it from within the new type, of course, and finally
3. subscribe to the event and keep the subscription around.

Discuss the topic in [a blog post on event publishing][eventpost] I wrote. I'd love to hear what you think!

[publisher]: https://github.com/DivineDominion/mac-multiproc-code/blob/master/RelocationManagerServiceDomain/DomainEventPublisher.swift

[eventpost]: http://christiantietze.de/posts/2015/03/event-publisher/

#### But can't we simply throw exceptions?

`distribute(_:)` could raise an exception. After all, it's a programmer error to invoke this method without prior checking for remaining capacity. For debugging purpose, this is fine, so we could add an `assert()` to the end of the method:

        public func distribute(itemTitle title: String) {
            if let box = boxes().first {
                // success!
                return
            }
        
            assert(false, "Insufficient total box capacity remaining "\
                "to distribute item '\(title)'")
        }

Keep in mind `assert` won't be of any help during production, though. Also, Swift doesn't even support any other kind of exception for control flow purpose -- unlike Java, for example. And effectively unlike Objective-C, too, although Objective-C folks would never have used exceptions in the first place.

I think the process should rather fail silently anyway: it's not a user-induced problem. Neither is it a weird condition in the outside world, like a lossy internet connection or unreachable servers. It's a rather simple error on our side if this method gets called at all with zero total capacity. Let's better make sure this never happens -- but don't crash the XPC service just because we forgot a check in the user-facing apps.

Since it's a programmer error, it should be okay to log what happened and move on. No data will be corrupted. The worst outcome is that no item will be created in the database and the user will not see the app show a change. This is bad enough, of course, but not fatal to the service.

To generate a lasting list of log entries, libraries such as [CocoaLumberjack][] come in handy. We could ask the user to send us the logs from time to time so we can get rid of nasty bugs.

[cocoalumberjack]: https://github.com/CocoaLumberjack/CocoaLumberjack


#### Distribute an Item Successfully: Delegate to ProvisioningService

The failure case was the most interesting so far because it introduced most of the problems. We left the happy path out, though. How does `DistributeItem` take care of creating an `Item`, assigning it to the `Box` that was found, and communicate success?

It delegates.

The three steps I just mentioned are not about _distribution_ anymore. They are what I call _provisioning_.

Let's imagine the specifications change in the future. We aren't meant to distribute items upon creation anymore. Instead, they may float around freely. The "Add Item" button will be labeled "Create Item". Then the user may manually put items from a list into boxes.

Recall the distribution process:

    if let box = boxes().first {
        // success!
        return
    }

In that case, finding a box prior to creating an item is not necessary anymore. Also, it's likely that the new process cannot fail for non-programmer reasons. After all, we would have to create an item only and that's it.

It doesn't make sense to call it "distribution" anymore, does it?

We are reasoning about the responsibilities or concerns of `DistributeItem`. I am a strong proponent of the [Single Responsibility Principle][srp]. Objects with multiple responsibilities are harder to reason about, harder to change, and thus harder to keep around. So we are going to aim to create objects which do only one thing, and not many.

The concern of `DistributeItem` is stated clearly thanks to the object's name: it distributes a new item. To find out which parts of a complex process belong here and not somewhere else, simply ask yourself: is this about distribution or about something else? If distribution was gone, should this other thing be gone too? If X does change, should Y change as well?

Item creation is not part of distribution. If we got rid of distributing items automatically in a future version of the software, items still have to be created somehow.

That's why we're going to leave `distributeItem(itemTitle:)` like this:

    var eventPublisher: DomainEventPublisher {
        return DomainEventPublisher.sharedInstance
    }

    let provisioningService: ProvisioningService
        
    public func distribute(itemTitle title: String) {
        if let box = boxes().first {
            provisioningService.provisionItem(title, inBox: box)
            return
        }
    
        eventPublisher.publish(ItemDistributionFailed(itemTitle: title))
    }

Now we're done with `DistributeItem` for now. We've delegated item creation to a `ProvisioningService`. Understanding the process isn't quite finished, so let's have a look at this new fella.

[srp]: http://en.wikipedia.org/wiki/Single_responsibility_principle

#### The ProvisioningService before and after a huge Model refactoring

Admittedly, I created the `ProvisioningService` earlier than I created `DistributeItem`. I thought I knew what was going to come, so I just wrote it. It was pretty straightforward in the early days:

    public func provisionItem(title: String, inBox box: Box) {
        let itemId = repository.nextItemId()
        let item = Item(itemId: itemId, title: title)

        box.addItem(item)
    
        let event = BoxItemProvisionedEvent(boxId: box.boxId, itemId: itemId, itemTitle: item.title)
        eventPublisher.publish(event)
    }

Create an item according to its specification. Then add it to a box. Publish a Domain Event to indicate success and tell interested parties, including the client apps, about the new item's ID.

Things changed when I implemented re-distribution of items upon box deletion. The Domain Model [at this particular point in time][commit-before] pictured `Box` as the only Aggregate Root. You'd access items through a box object only. This didn't work well to implement _moving_ items. I was able to delete and re-create similar items, but then I wouldn't change one and the same Entity but create a new one. That's not what was specified by the business rules. "Moving" means that the item moved stays the same.

Of course I could make the client apps work just as well. The point is that this would equal cheating. Cheating on the business rules, and cheating on the intent of a Domain Model. It is meant to reflect the business rules, not bend them so it looks like what was ordered on the outside.

With our not quite so interesting example application, the net gain of adhering to principles of Domain Driven Design religiously is nearly zero. Adhering to the principles is part of the deal of this book, though. The example app may be contrived, but we still have to code as if it's complex enough to warrant multiple application products, persistence with Core Data, and a real software architecture.

So no cheating allowed.

We need to get a handle to the item about to be moved _and_ give it the power to move to another box. With the old model, `Item` didn't have that power. Everything was done through the outside world-facing root object of the Aggregate: `Box`.

Moving items from one box to another means that an item is moved, not that a box moves an item to another box, though. To reflect this, we have to tear `Box` and `Item` apart a bit. Box can still be the root of its own Aggregate, but now `Item` will be an Aggregate, too.

With two Aggregates instead of one, the process changes quite a bit. Here is the relevant part:

    public class ProvisioningService {
        var eventPublisher: DomainEventPublisher {
            return DomainEventPublisher.sharedInstance
        }
    
        let boxRepository: BoxRepository
        let itemRepository: ItemRepository
        public lazy var identityService: IdentityService = IdentityService(boxRepository: self.boxRepository, itemRepository: self.itemRepository)
    
        // ...
        
        public func provisionItem(title: String, inBox box: Box) {
            let item = box.item(title, identityService: identityService)
        
            itemRepository.addItem(item)
        
            let event = ItemProvisioned(itemId: item.itemId, title: item.title)
            eventPublisher.publish(event)
        }
    }

In detail, the changes include:

* `Box` has a factory method `item(_:,identityService:)` to create an object which is assigned to the box already. _Tell, Don't Ask_: instead of querying the box for its ID, let it do the creation inside its Aggregate bounds. (In fact, I should've used it in the first iteration, too. Take this as an example of iterating towards expressiveness of the model.)
* The new `IdentityService` provides `nextBoxId()` and `nextItemId()`, of which the latter will be used during item creation. These are things a Repository could provide, too. But if we pass a Repository to `Box`, what should it be allowed to do? Create? Remove? `IdentityService` limits the power by hiding the Repositories' other methods. That's its sole job.
* `Box.addItem(_:)` is gone. Items are added to their Repository directly.
* The event has changed. `ItemProvisioned` doesn't take the box into account anymore. <!--ct: TODO is it a good idea to not include boxId in the event (for convenience) -->

Adding items to the Repository directly has huge consequences concerning obtaining items. No box will know its items by default anymore. Since they can change independently of the box, they have to be obtained through the `ItemRepository`.

The same rationale of `IdentityService` applies: if you query `Box` for Aggregate information, it needs access to the Repository, only without full access to the Repository. The protocol `ProvidesBoxItems` comes into play here. It provides information about items related to a box and is used like so:

    public class Box: NSObject {
        // ...
        public func itemsCount(itemProvider: ProvidesBoxItems) -> Int {
            return itemProvider.count(boxId: boxId)
        }
    }

All this double dispatching seems weird at first, but it's okay if we want to keep putting meaningful methods inside `Box`. If we don't, we end up with mere data containers instead of a full-fledged Domain Model. Again, because the example application is so simple, it's hard to come up with really breath-taking features.

So now we understand how items are created and distributed in the two relevant Domain Services `DistributeItem` and `ProvisioningService` in conjunction with the new factory method on `Box`.

Other use cases are handled in a similar fashion.

Before we take a look at other interesting cases, I want to step back a bit. Could things fail even for this simple task? It seems so: concurrent threads can interfere with each other during item distribution. So let us discuss race conditions and transactional consistency.

[commit-before]: https://github.com/DivineDominion/mac-multiproc-code/tree/4a0439bbf9e3e628543962ac87c889308b109ea1/RelocationManagerServiceDomain


### Services are Prone to Race Conditions

Race conditions occur when the software attempts to perform multiple operations at the same time, but not in the proper sequence, or in such a way that they interfere with each other.

Even in the most simple procedure will you find wiggle room for concurrency-related problems to occur.

Simplified, `distribute(_:)` takes care of the following:

1. Fetch boxes from their Repository
2. Filter results to find a suitable box
3. Add item to the box

Between steps 1 and 3, a concurrent operation may interfere. Suddenly, the previously picked box isn't valid anymore because another thread has added another item to it. Adding another item will fail.

In other words, the data from our store got stale in between.

No matter how we change the code and refactor the design, there's no way to make a single _transaction_ of this from the database point of view. It'll always be made up of a _read_ operation, and a _write_ operation, with potential for causing trouble in between. It's not a single, atomic operation.

Service objects are codified tasks. Some may even represent whole use cases. `DistributeItem` comes pretty close to a simple use case. Most tasks aren't trivial one-liners -- and if they were, would you create a new kind of object for them? Since most tasks consist of multiple steps, they are prone to changes in the context. So watch out whether Services may interfere with each other when their tasks are executed simultaneously.

What can we do to protect against race conditions?

#### Protecting Against Race Conditions Is Not Part of the Domain

The Domain doesn't know anything about race conditions. If you put protection against race conditions into your Domain, you fall for the fallacy [Gojko Adzic calls][gojko] "race conditions hide business rules."

We might be tempted to say: if the task of "distributing an item" may fail because of race conditions, then we have to add means to protect against these into our set of business rules. We discovered a lack of rules through programming. Let's add a new rule, implement it, and move on.

However, some or most race conditions are clearly not a sign of a lack of business rules. The business rules don't need to encompass what happens when two threads of your application interfere. The notion of "application" or "thread" is not part of the business. The business deals with providing some kind of solution to a specific problem, and our software is there to automate this and to make it more efficient.

Business rules can deal with how to remedy mistakes people make, for example. They cannot deal with the hardware of a particular computer, or with the details of multi-threading. That's a whole different set of problems, namely problems of implementation in code.

Without software, race conditions wouldn't occur. Consequently, they can't be part of the Domain.

If we had to locate race condition prevention in our architecture, it'd be a matter of the Application Layer at best, since it's the client of the Domain.

So we've pushed the problem out of the Domain. Instead of `DistributeItem`, its client object, called `ManageItems`, will deal with race conditions.

`ManageItems` implements `distributeItem(_:)` to create a bridge into the domain. It basically looks like this:

    public class ManageItems {
        // ...
        public lazy var distributionService: DistributeItem = DomainRegistry.sharedInstance.distributeItem()
    
        public func distributeItem(title: String) {
            distributionService.distribute(itemTitle: title)
        }
        // ...
    }

It's rather boring because there isn't much to do for the Application Service in this particular case. To justify having it around in the first place, have a look at another of its methods:
        
    // ...
    public lazy var removalService: RemoveItem = DomainRegistry.sharedInstance.removeItem()
    
    public func removeItem(itemIdentifier: IntegerId, fromBoxIdentifier boxIdentifier: IntegerId) {
        let itemId = ItemId(itemIdentifier)
        let boxId = BoxId(boxIdentifier)
        
        removalService.remove(itemId, fromBox: boxId)
    }
    // ...

Here, the Application Service's task is to transform the primitive integer values into Value Objects the Domain understands. Then it invokes the appropriate command handling mechanism: `RemoveItem.remove(_:,_:)`.

The Application Service has to make a transactional consistent process out of this. If removal is started, it should work. No other thread should interfere.

#### Put Sequential Processes on a Shared Queue

Multiple connections from client apps to the XPC service will possibly result in multiple threads on the XPC service process.

One rather simple trick is to make them sequential. Create a queue for the XPC service which all incoming threads will execute their tasks on. The actual order of tasks cannot be determined, but each task will have to be completed before the next is allowed to start. At least it'll suffice to check for valid state once and rely on it until task completion under these circumstances.

Here's the `ManageItems` Application Service after I added the notion of a simplified ["unit of work"][uow]:[^fowler2009peaa]

    public class ManageItems {
 
        public lazy var distributionService: DistributeItem = DomainRegistry.sharedInstance.distributeItem()
        public lazy var removalService: RemoveItem = DomainRegistry.sharedInstance.removeItem()
    
        public init() { }
    
        public func distributeItem(title: String) {
            exit
            ServiceLocator.unitOfWork().execute {
                self.distributionService.distribute(itemTitle: title)
            }
        }
    
        public func removeItem(itemIdentifier: IntegerId, fromBoxIdentifier boxIdentifier: IntegerId) {
            let itemId = ItemId(itemIdentifier)
            let boxId = BoxId(boxIdentifier)
        
            ServiceLocator.unitOfWork().execute {
                self.removalService.remove(itemId, fromBox: boxId)
            }
        }
    }

It doesn't matter how a unit of work is implemented. The Service simply relies on it to work.

Thanks to Core Data, we can call `performBlock` or `performBlockAndWait` on a `NSManagedObjectContext` to achieve transactional consistency. That's how [this particular `UnitOfWork` object][myuow] works, basically.

Without Core Data, we'd have to use our own serial or private dispatch queue. Give it a name so all threads access the same queue. Enqueue tasks sequentially. Then you're safer than before.

That's about prevention, and it might be all you need, given the task is sufficiently simple.

If this won't work, you need to be able to recover from race conditions.

[uow]: http://martinfowler.com/eaaCatalog/unitOfWork.html
[myuow]: https://github.com/DivineDominion/mac-multiproc-code/blob/master/RelocationManagerServiceDomain/UnitOfWork.swift

[^fowler2009peaa]: For details on the way more powerful pattern, see Martin Fowler (2009):  _Patterns of Enterprise Application Architecture_, Boston: Addison-Wesley.


#### Recovering From Race Conditions

There are two paths you can take to recover from bad state: retry or compensate.

In our application, this means the following:

* **Can we retry?** Only two slots are free, one in each of two boxes. We add two items concurrently. Both get assigned to the same box at first. One item wins by a fraction of a second and gets added to the box. Adding the other fails. Can we retry to add the same item to another box? Yes, and this would totally work as expected.
* **Can we compensate?** Only one slot is free but we process adding two items. The user things both items are on their way. Can the second item be put into another place? Not yet. Ordering a spare box to take care of the leftover item seems to be out-of-place to me. I'd rather let the item drop than make a surprise box addition. In this rare case, we can also tell the user we're sorry to have accepted the second item although the capacity doesn't suffice, and ask if we should drop it or order a new box. Avoiding data loss is always good.

Usually, retrying is easy when you return a Boolean to indicate success or failure:

    for box in allBoxes {
        if box.addItem(item) {
            // Stop trying if it worked once
            break
        }
    }

This violates the principle of command--query-separation. That's okay, no one will die because of this. Someone came up with the principle of separating commands from queries to because this is how your code will become more robust and side-effect free.

Doing it the ugly way once won't break anything, but it may induce a bad tendency to make your code worse overall. We have to ask ourselves if it's worth the trade-off. 

Compensating is a bit more tricky: Which part of the application will know how to compensate?

Think about the various [flavors of messages][flav] in your code base.

* There are commands, of which you expect to perform changes. 
* There are queries, which should be strictly side effect-free. 
* There are notifications and events, broadcasting information without expecting any particular reaction.

Notifications are a means to achieve loose coupling between components and consequently cannot expect any reaction. With our distributed application, spread across various processes, it's natural to go for them to inform interested parties (other stand-alone parts of the app) about failing operations.

Any party can compensate for the failure by its own means as long as it listens for the event.

Since we adopted Domain Events already, broadcasting events isn't the exception.

In this concrete situation, it'll be natural to broadcast an `ItemDistributionDidFail` notification. That's enough to show an alert dialog to the user, for example.

If we attach the item data to the event, the main organizer app can compensate for the failure easily:

* It receives an `ItemDistributionDidFail` event.
* It doesn't know which item caused trouble. (Since no item was created, it in fact doesn't make sense to ask for it.) It finds a complete item representation attached to the event, though, so it can display the item information.
* It can ask the user for more boxes in an alert. If she agrees to order an additional box, the main app can send the item distribution order again afterwards (and consequently forget about the item details from the event).
* After ordering a new box, the XPC service now has plenty of storage and distributes the item. Everyone's happy.

Sending events doesn't take seconds or minutes. It's nearly just as fast as sending messages to objects directly. (Of course, there's at least one more hop in between, but that amounts to almost nothing.)

From a user experience perspective, it doesn't matter whether you couple parts loosely and send events or if you violate the principle of command--query-separation to get immediate feedback on commands.

All of this is about increased programmer happiness and higher-quality code.

We split up the app into three autonomous components to make the application maintainable on the macro level. We should continue to strive for the most robust solution on the meso and micro level, too: the former being about object collaboration and messages, the latter about internal structure of objects. That's why I will explore the event-based path further, as a means to optimize the meso level.

[flav]: http://verraes.net/2015/01/messaging-flavours/
[gojko]: http://gojko.net/2010/06/11/udi-dahan-the-biggest-mistakes-teams-make-when-applying-ddd/


### Taking a Look at the Simple `RemoveItem` Domain Service

A straightforward Domain Service is `RemoveItem`. It checks whether the command can be performed prior to removing an item from its Repository. If the check fails, it sends a failure event. If it succeeds, and after the change has been performed, it publishes a success event.

It's a pattern similar to `DistributeItem`:

{linenos=off}
    public class RemoveItem {
        // ...
        public func remove(itemId: ItemId, fromBox boxId: BoxId) {
            if !itemExists(itemId, inBox: boxId) {
                eventPublisher.publish(ItemRemovalFailed(itemId: itemId, boxId: boxId))
                return
            }
        
            itemRepository.removeItem(itemId: itemId)
        
            eventPublisher.publish(ItemRemoved(itemId: itemId))
        }
        // ...
    }

The pattern seems to work really well in this case. Simple Domain Services just read well, too.

Now that we've established and tested the pattern already, let's have a look at what was maybe the hardest Service to model: removing a box and redistributing its items with `DissolveBox`.

### Manage Round-Trips through the Domain in `DissolveBox`

`DissolveBox` has clear objectives. If the box to be dissolved exists, ...

1. empty the box, and then
2. remove the box.

The relevant part of this use case is the following method:

    public class DissolveBox {
        // ...
        public func dissolve(boxId: BoxId) {
            if let box = boxRepository.box(boxId: boxId) {
                emptyBox(box)
                removeBoxIfEmpty(box)
                return
            }
        
            eventPublisher.publish(BoxRemovalFailed(boxId: boxId))
        }
        // ...
    }

It was hard to make `emptyBox(_:)` and `removeBoxIfEmpty(_:)` actually do a thing without duplication. Emptying a box means to re-distribute all of its items. `DistributeItem` does the distribution thing already, so I wanted to use its knowledge somehow. But I also didn't want to pass the `Box` around between Services just like that.

After a few iterations in designing the message flow, I came up with the following methods:

    func emptyBox(box: Box) {
        box.dissolve(distributionService)
    }
    
    func removeBoxIfEmpty(box: Box) {
        if !box.isEmpty(itemRepository) {
            eventPublisher.publish(BoxRemovalFailed(boxId: box.boxId))
            return
        }
        
        boxRepository.removeBox(boxId: box.boxId)
        
        eventPublisher.publish(BoxRemoved(boxId: box.boxId))
    }

`removeBoxIfEmpty(_:)` should look familiar already, since it uses the success/failure event pattern we just established.

`emptyBox(_:)` lets a box dissolve its contents itself. It's _Tell, Don't Ask_ again. `distributionService` is an instance of `DistributeItem`, but to `Box` it looks like a `RedistributesItems` only:

    public protocol RedistributesItems {
        func redistributeItems(box: Box)
    }
    
    class Box {
        // ...
        public func dissolve(redistributionService: RedistributesItems) {
            redistributionService.redistributeItems(self)
        }
    }

Double dispatch again, not doing much else here within `Box`.

Again, I'm passing the call through like this to achieve two things. First, I want to keep `Box` expressive through intention revealing method names, even though `Box` needs a helper for a lot of the tasks. Second, I want to adhere to the principles of _East-Oriented Code_ and _Tell, Don't Ask_ first and see how things go afterwards.

If it becomes too clumsy to use, I model the process differently.

For example, I could call `redistributeItems(theBox)` directly from  within `emptyBox(_:)`. It's still telling instead of asking and we're skipping an otherwise needless loop through `Box`. The drawback? The public `Box` interface will be less expressive. If you read the code and want to find out how to empty a box, you're screwed if there's no method which indicates "how to empty" or, in this case, "how to dissolve a box".

Being able to grasp how to work with a Domain Model object is one of the large benefits of having a Domain Model in the first place. Giving this up for the sake of saving a line of code doesn't seem to be worth it to me. Again, since this is an arbitrary example app, you may experience even greater benefits in your projects.

This is how `redistributeItems` is implemented:

    public func redistributeItems(box: Box) {
        if totalRemainingCapacityInsufficient(box) {
            eventPublisher.publish(BoxItemsRedistributionFailed(boxId: box.boxId))
            return
        }
        
        moveItems(box)
    }
    
    func totalRemainingCapacityInsufficient(box: Box) -> Bool {
        let otherBoxes = boxesExcept(box)
        let totalRemainingCapacity = otherBoxes.reduce(0, combine: remainingCapacity)
    
        return totalRemainingCapacity < itemsCount(box)
    }

    func boxesExcept(box: Box) -> [Box] {
        // We know boxes() from before: it fetches all boxes, sorts, and
        // filters them. Here, we exclude the box we want to get rid of.
        return boxes().filter { return $0 != box }
    }
    
    // This one is used by `reduce`
    func remainingCapacity(initialCapacity: Int, box: Box) -> Int {
        return initialCapacity + remainingCapacity(box)
    }
    
    func remainingCapacity(box: Box) -> Int {
        return box.remainingCapacity(takingItemsFrom: itemRepository)
    }

If you haven't used `reduce` before, it does the following in this case:

* starting with an initial capacity value of 0, it
* iterates over all boxes in `otherBoxes`,
* applying `remainingCapacity(_:Int,_:Box) -> Int` to it, which
* takes the current capacity and a box to compute the next capacity.

In short, this call to `reduce` performs an addition of all box's `remainingCapacity`s. Instead of providing block, I passed in a method reference to `remainingCapacity(_:Int,_:Box) -> Int`, which performs the addition.

That's not much of an algorithm so far. `moveItems` is where the actual processing takes place:

    func moveItems(box: Box) {
        let items = itemRepository.items(boxId: box.boxId)
        
        for item in items {
            let otherBoxes = boxesExcept(box)
            
            if let newBox = otherBoxes.first {
                item.moveToBox(newBox)
            }
        }
    }

Did you notice that I pass the box to be dissolved around everywhere, even in the scope of these objects? I avoid stateful Services to keep only a single instance around at best. Also, not having state in an object means it cannot be broken. Services become containers of mere functions and provide a bit of context, like which Repositories to use.

The `moveItems` algorithm has a big pain point: in line 5, it fetches and filters all boxes during every iteration of the loop. This is quite a waste, but I don't expect much of a difference if I optimized this. With the current specification, a box may contain no more than 20 items. This is an easy way to ensure that for every item, there's a box with some capacity available. The data cannot get stale this way.
<!--ct: TODO check line number-->

`redistributeItems` has checked if the total remaining capacity is sufficient already. But we cannot yet assume that things haven't changed. This Domain Service won't (and shouldn't) deal with race conditions, so if somehow the remaining total capacity changed to the worse while looping through all items, and if one or more items cannot be moved due to a lack of spare capacity, then the box won't be empty afterwards.

That's okay for the scope of the `RedistributesItems` protocol. It tries to deliver. Its consumer has to take care of verifying the state. And `DissolveBox` does by checking if the box to be dissolved actually is empty.

In fact, you could argue that `RedistributesItems` should simply try to move as many items as possible, and that the check for sufficient remaining capacity before trying to move items is unnecessary. I'd say that redistribution does entail all of a box's contents, though, or we'd have to call it "redistribute as many items as possible" instead. "To redistribute" implies success already. Just like you cannot say you "found a coin" without actually having seen (and maybe picked up) a coin, you cannot redistribute items without actually moving all items. With expressive design, a lot of the decisions are decisions about language.

In fact, the Ubiquitous Language is a key component of Domain-Driven Design which we try to apply here. It's expressed in the specifications very well already. When we model software, we have to listen to the concepts and help make them as specific as possible to contribute to the model in code. The Domain Model should resemble the mental model of the problem space.


## Implement the XPC interfaces
