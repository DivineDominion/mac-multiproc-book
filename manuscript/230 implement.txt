# Implementing Processes

## Bootstrapping a Multi-Process Xcode Project {#bootstrap}

To create a Cocoa application is one thing. To mangle with build settings to create an app bundle with multiple components is another. I don't feel comfortable mangling with build settings still, but neither do I feel like a stranger there anymore. I don't know if that's a good sign. I'd rather have it work out of the box, but what can we do.

Let me guide you through the process of creating a project from scratch and setting everything up so it'll actually work.

### Keep Your Mac Developer Program's Team Identifier Handy

If you are enrolled to the Mac Dev Program, you got your own "team identifier." You can find it online, in Apple's Developer Center. You'll need this for the setup.

If you didn't shell out the bucks to get a license to code for Mac (yet), simply don't enable app sandboxing and don't fiddle with code signing, as both depend on valid registered developer profiles.

### Create the Targets

![New Project Settings](images/201501201655_create-project.png)

Create a new Xcode project and pick OS X "Cocoa Application". I use Swift and Core Data but no Storyboards.

Add an XPC Service target right afterwards. You find them under "Frameworks & Library" in the OS X group as of Xcode 6. We'll have to costimize the XPC Service target because nowadays it seems to work differently than people were used to. Call the future Launch Agent "Helper". We'll modify the names soon enough to make sense.

![Add the Helper Target](images/201501201656_create-helper-target.png)

Still under the "General" tab of the targets, select either Developer ID or Mac App Store signing. Using none will not work with sandboxing. But we will use sandboxing to make our app safe and future-proof and possibly App Store compatible.

Note that the XPC service target or helper target is Objective-C instead of Swift. Maybe there's a reason for it, but I wouldn't know which. We'll get it running first and translate to Swift later.

### App Capabilities: Set Up Proper Sandboxing 

Enable Sandboxing for both the app and the XPC service target.

Add an app group to let both processes communicate with each other. Pick an app group name of the form `<tem-id>.<organization>`. My organization identifier is `de.christiantietze`. I want the app components to share data, but not all apps created by me, so I want to limit the scope of the processes to the overall app group "multiproc" (for "multiple processes") for this project. My team ID is `FRMDA3XRGC`. The resulting app group I add to both targets will be `FRMDA3XRGC.de.christiantietze.multiproc`, accordingly.

![Add App Group](images/201501201701_app-groups.png)

When you add an app group, it's important you're not fooled by the `$(TeamIdentifierPrefix)` variable, which is the default value. This variable will likely [be `nil` during development][teamidnil]. That should be okay when you write XPC helper processes which are launched by the app itself on demand.[^helperex] But it only causes you pain when you work with login items and try to connect to a system-wide Mach-Service. Put your team identifier in there manually to make things work during development. Don't ask me why, but it's [the only way I got this running][ctde-appgroup] during development.

Although the docs don't say it, I found the app group needs to be a substring of both target's bundle identifiers. The XPC Service is currently called `de.christiantietze.Helper`, which won't do. Rename both processes so that the bundle component `multiproc.` is in there.

[teamidnil]: http://stackoverflow.com/a/13180926/1460929
[ctde-appgroup]: http://christiantietze.de/posts/2015/01/xpc-helper-sandboxing-mac/

[^helperex]: If you are interested in leveraging XPC to put heavy work into helper processes and take the load from your main application, the online periodical objc.io #14 features [a very good article about XPC helper services](http://www.objc.io/issue-14/xpc.html) for you.

### Make the XPC Service a Launch Agent

Launch Agents have to be placed in the `.app` bundle's `Contents/Library/LoginItems` subfolder. Their name has to equal the bundle name. Launch Services will create the appropriate Mach-Service to connect to on our behalf this way.

* Search for "Product Name" in the Helper's build settings tab and set it to `<team-id>.<bundle-name>`. In my case, this is: `FRMDA3XRGC.de.christiantietze.multiproc.Helper`.
* Change the value of the "Wrapper Name" build setting to "app" instead of "xpc". Although the docs say Launch Agents may not end with `.app`, it didn't work for me.
* Modify the XPC Sercvice's `.plist`: replace the value of "Bundle Identifier" with `$(PRODUCT_NAME)` only, no RFC escaping, no organization prefix. The RFC-escaped version would replace the bundle identifier's delimiting periods with dashes. That'd not be good.
* Delete "Embed XPC Service" build phase. We're not just splitting an app into XPC components but want to create a Launch Agent and need to meet other criteria.
* Add a copy file build phase. Destination: "Wrapper". Subpath: "Contents/Library/LoginItems". Drag and drop the helper target's product alias in there. (You find build products to your left in the Standard Editor's "related files" section below the "Products" group.)

### A Note on Maintaining the Launch Agent's Target

When you install Launch Agents manually, you put them into `~/Library/LaunchServices/` and call `launchctl load`, followed by the file name. To stop using an Agent, you call `launchctl unload`, followed by the Agent's file name again.

This doesn't work in our case since we automate launching the process and keep the file in our app bundle.

To not only stop execution (which results in relaunching the Agent) but remove the Agent from the list (like `unload` does usually), you have to use the `remove` command. `launchctl remove` removes not by file name, but by service name. In my case, I stop and get rid of the helper process with the following command from the Terminal:

{linenos=no}
    launchctl remove FRMDA3XRGC.de.christiantietze.multiproc.Helper

To make changes take effect after building a new version of the helper, `stop` will suffice to reload the service, though:

{linenos=no}
    launchctl stop FRMDA3XRGC.de.christiantietze.multiproc.Helper

You can automate this with Xcode build scripts to get rid of the helper with every run. This is especially useful for the early development.

## Implement a communication API

By now, both app targets should compile. They don't do anything, though. You should be able to invoke the helper application manually, too. Now let's add means to make the main app start the helper if it isn't running.

I will guide you through the process of creating your own interacting processes from scratch in this section.

If you want to have a look at the outcome of this only and find the step-by-step guide too long, just download the [demo app's code after the adaptation from GitHub]201501221730github and look at the result. See you in [the next section](#sec:testdriveapi)!


### Define a shared protocol

To set up the `NSXPCConnection`, we need to supply a protocol to communicate with the helper by proxy.

I like to give protocols names which state capabilities. Instead of `XPCHelperProtocol` or something I am going to use `ProvidesCounts` for now:

{linenos=no}
    @protocol ProvidesCounts
    - (void)currentCountWithReply:(void (^)(NSUInteger))reply;
    @end

I put `ProvidesCounts.h` into a source file group called "Shared Sources" at root level. Both targets will use this.

The helper's target, being Objective-C anyway, can simply import the file.

The Swift target, though, needs bridging headers. They are used to import Objective-C stuff into the Swift module. Create a file called `<app-product-name>-Bridging-Header.h` in the Swift app module. In my case, this is called `MultiProcCounter-Bridging-Header.h`, with "MultiProcCounter" being the target's and the bundle's name. Next, modify this target's build settings. Search for "bridging headers" and set "Objective-C Bridging Headers" of the product to `<product-path>/<product-name>-Bridging-Header.h`. In my case, this is `MultiProcCounter/MultiProcCounter-Bridging-Header.h`. The path is relative to the group. Usually, the folder is called the same as the product/target when you create it. Now, import the protocol in this bridging header:

{linenos=no}
    #import "ProvidesCounts.h"

That's it for the Swift-based target.

The helper's template includes the `Agent` protocol which we don't need anymore. The sample helper object, mine is called `MultiProcCounterHelper`, just like the service's target, has to implement `ProvidesCounts` instead.

    // MultiProcCounterHelper.h
    @interface MultiProcCounterHelper : NSObject <ProvidesCounts>
    @end

    // MultiProcCounterHelper.m
    @implementation MultiProcCounterHelper
    - (void)currentCountWithReply:(void (^)(NSUInteger))reply
    {
        reply(1337);
    }
    @end

Replacing the `Agent` protocol with `ProvidesCounts` in the helper's `main.m` where necessary, we end up with a `ServiceDelegate` which actually becomes the listener for XPC connections:

    // main.m
    @interface ServiceDelegate : NSObject <NSXPCListenerDelegate>
    @end

    @implementation ServiceDelegate
    - (BOOL)listener:(NSXPCListener *)listener shouldAcceptNewConnection:(NSXPCConnection *)newConnection {
        newConnection.exportedInterface = [NSXPCInterface interfaceWithProtocol:@protocol(ProvidesCounts)];
        MultiProcCounterHelper *exportedObject = [MultiProcCounterHelper new];
        newConnection.exportedObject = exportedObject;
        [newConnection resume];
    
        return YES;
    }
    @end

### Make use of the shared protocol

Now tweak `AppDelegate` to connect to the helper and obtain a value. The client application will set up the connection like this:

{title='Listing 1.1: AppDelegate.swift using NSXPCConnection'}
    @NSApplicationMain
    class AppDelegate: NSObject, NSApplicationDelegate {

        @IBOutlet weak var window: NSWindow!
        var helper: ProvidesCounts?

        func applicationDidFinishLaunching(aNotification: NSNotification) {
            var error: NSError?
            // I'll show you what createXPCConnection() looks like in a moment.
            let maybeConnection = createXPCConnection("FRMDA3XRGC.de.christiantietze.multiproc.Helper.app", &error)
            if (maybeConnection == nil) {
                NSLog("connection failed %@", error!.description)
                return
            }
            let connection = maybeConnection!
        
            connection.remoteObjectInterface = NSXPCInterface(`protocol`: ProvidesCounts.self)
            connection.resume()
        
            helper = connection.remoteObjectProxyWithErrorHandler() { (err) -> Void in
                NSLog("Failed to send message: %@\n\n", err.description)
            } as? ProvidesCounts
        
            if helper == nil {
                NSLog("No helper")
            }
        
            helper!.currentCountWithReply() { (result) -> Void in
                NSLog("The result is: \(result)")
            }
        }
    }

There's a lot of `NSLog`ging going on for now. Of course this is going to be replaced by real error-handling mechanisms. You should be aware of the possible points of failure: starting up the service may fail. Or it starts up but the XPC connection doesn't work and you don't get a proxy object. Or you get a proxy object, but sending the message fails because the service crashes in between.
<!--ct: TODO when do you not get a remoteObjectProxyWithErrorHandler()? Outdated versions?-->

### XPC connection factory

I used a little helper method here, `createXPCConnection()`, which takes the file name of the helper app. I adapted it from Apple's own demo code [AppSandboxLoginItemXPCDemo][xpcdemo]. Instead of extending `NSXPCConnection` and supplying a new convenience initializer, I used a factory function here. Mostly because the initializer wouldn't compile for reason I cannot fathom.

    func createXPCConnection(loginItemName: NSString, error: NSErrorPointer) -> NSXPCConnection? {
        let mainBundleURL = NSBundle.mainBundle().bundleURL
        let loginItemDirURL = mainBundleURL.URLByAppendingPathComponent("Contents/Library/LoginItems", isDirectory: true)
        let loginItemURL = loginItemDirURL.URLByAppendingPathComponent(loginItemName)
    
        return createXPCConnection(loginItemURL, error)
    }

The actual factory called here takes a URL instead of a file name.

{title='Listing 1.2: createXPCConnection() factory'}
    // Since Swift doesn't care about ancient Boolean types, create convenience
    // constants for later. (SMLoginItemSetEnabled will need these.)
    let TRUE: Boolean = 1 as Boolean
    let FALSE: Boolean = 0 as Boolean
    
    func createXPCConnection(loginItemURL: NSURL, error: NSErrorPointer) -> NSXPCConnection? {
        let loginItemBundle = NSBundle(URL: loginItemURL)
    
        if loginItemBundle == nil { // ❶
            // populate error pointer ...
            return nil
        }
    
        if loginItemBundle!.bundleIdentifier? == nil { // ❷
            // populate error pointer ...
            return nil
        }
        let loginItemBundleId = loginItemBundle!.bundleIdentifier!
    
        let loginItemBaseName = loginItemURL.lastPathComponent!.stringByDeletingPathExtension
        if loginItemBundleId != loginItemBaseName { // ❸
            // populate error pointer ...
            return nil
        }
    
        if SMLoginItemSetEnabled(loginItemBundleId as CFString, TRUE) != TRUE { // ❹
            // populate error pointer ...
            return nil
        }
    
        return NSXPCConnection(machServiceName: loginItemBundleId, options: NSXPCConnectionOptions(0))
    }

1. Load the bundle at the specified URL.
2. Lookup the bundle identifier for the login item. LaunchServices implicitly registers a mach service for the login item whose name is the name as the login item's bundle identifier.
3. The login item's file name must match its bundle Id.
4. Enable the login item. This will start it running if it wasn't already running.

If all of this works, we get an XPC connection.

That's a lot of checks and a lot of things which can go wrong. Good news is: all of these are programmer errors. If you distribute the app properly, they won't surprisingly happen in the wild.

[xpcdemo]: https://developer.apple.com/library/mac/samplecode/AppSandboxLoginItemXPCDemo/Introduction/Intro.html


### Getting rid of Objective-C code in favor of Swift

The XPC service target's code is in Objective-C by default. I don't know why, though. [Other folks][adf-swift] on the Apple Developer Forums use Swift for their XPC service without issues, and so will we. 

Here's what you have to do to get rid of Objective-C code altogether:

* Set "Embedded Content Contains Swift Code" in the helper's build settings to "YES" to use Swift in the first place.
* Delete all `.h` and `.m` files, including the shared protocol and bridging headers.
* Add a `HelperServices.swift` file which will contain the shared protocol. Both the app and the helper target need to use this. See listing 1.3 below.[^namespaces]
* Add a `main.swift` file to the helper with the code of the listing 1.4 below.
* Compile and run and rejoice.

{title='Listing 1.3: HelperServices.swift'}
    import Foundation

    @objc(ProvidesCounts)
    protocol ProvidesCounts {
        func currentCount(reply: ((UInt) -> Void)!)
    }


{title='Listing 1.4: main.swift (in XPC Service's Target)'}

    import Cocoa

    class TheHelper : NSObject, ProvidesCounts {
        func currentCount(reply: ((UInt) -> Void)!) {
            reply(4455)
        }
    }

    class ServiceDelegate : NSObject, NSXPCListenerDelegate {
        func listener(listener: NSXPCListener!, shouldAcceptNewConnection newConnection: NSXPCConnection!) -> Bool {
            newConnection.exportedInterface = NSXPCInterface(`protocol`: ProvidesCounts.self)
            var exportedObject = TheHelper()
            newConnection.exportedObject = exportedObject
            newConnection.resume()
            return true
        }
    }

    let bundleId = NSBundle.mainBundle().bundleIdentifier!
    let delegate = ServiceDelegate()
    let listener = NSXPCListener(machServiceName: bundleId)
    listener.delegate = delegate;
    listener.resume()
    NSRunLoop.currentRunLoop().run()

I like the Swift version better, mainly because the code is a lot more terse for what it accomplishes.

[^namespaces]: It'd be cool if you could easily create Swift modules as namespaces to share code. But creating a `.swiftmodule` manually [takes too many steps](http://railsware.com/blog/2014/06/26/creation-of-pure-swift-module/) to pay off for sharing a single protocol between two targets.

[adf-swift]: https://devforums.apple.com/message/1092054#1092054

### Recap

When the project is prepared, you need to perform the following steps in code to get the XPC service up and running and have the client app connect to it:

* Define a protocol to use on both sides: the XPC service has to provide an object which implements the protocol while the client uses the proxy object. I called this protocol `ProvidesCounts`.
* Add bridging headers to Swift targets to make the protocol available there.
* Expose the object which implements the protocol in the `NSXPCListener` implementation, here in `ServiceDelegate`. Use `NSXPCInterface`'s `exportedObject` property for this.
* On the client side, start the XPC service as a login item via `SMLoginItemSetEnabled()`.
* Then obtain the result of the connection's `remoteObjectProxyWithErrorHandler()`, cast it to your shared protocol, here `ProvidesCounts`, and use it like any other object.

Run the app and see what happens. In my case, it prints the number to the console as expected. Congratulations! This was a lot of effort for not very much. But from now on, we can roll quickly and add real application logic.

If you didn't follow along in your code, check out the demo app [with changes this far][201501221730github].

[201501221730github]: https://github.com/DivineDominion/mac-multiproc-code/tree/001-xpc-bootstrapping

## Test-Driving the XPC API {#sec:testdriveapi}

### Make the connection bi-directional
### Handle connection interruptions

> You’ll typically have interruption handlers in your application and invalidation handlers in you xpc service.
> http://blog.yvs.eu.com/2013/07/cocoa-interprocess-communication-with-xpc/

### Remove the old Helper process automatically with every build during initial development

When you get started with developing the processes, it's going to get on your nerves to manually shut down or restart the background process all the time. Instead, add a script to your build phases to stop the process on every build.

<!--ct: TODO add listing name: "Remove old Helper Script Build Phase"-->
{linenos=no}
    if launchctl list | grep de.christiantietze.multiproc; then
        echo "Removing Helper…"
        launchctl remove FRMDA3XRGC.de.christiantietze.multiproc.Helper
    else
        echo "No Helper was Running."
    fi

This is not what you are going to want later on, but it'll suffice to get past the initial trouble. To restart or shut down the helper manually, you can create an Automator service to execute this script and add a shortcut to it. Or you use a script launcher like Keyboard Maestro.

By all means: do yourself a favor and don't use the Terminal directly everytime.

## Testing XPC Calls: Define Adapters

## Dealing with crashes
* Launch Services takes care of restarting the helper
* add a lock-like token to find out if it crashed or if it was quit on purpose
* inform the user from the UI processes (background status item, or main app)